#!/usr/bin/env python
"""
    %prog run is2n
"""
from __future__ import print_function
import sys
import os
import numpy
from numpy import sqrt, array, diag

import fitsio

import ngmix
import nsim

import time

from optparse import OptionParser
parser=OptionParser(__doc__)

parser.add_option('--skip',default=None,
                  help="is2n elements to skip")
parser.add_option('--pqr-cov',action='store_true',
                  help="use the pqr covariance (effectively assuming no ring)")

parser.add_option('--jackknife',action='store_true',
                  help="use jackknife errors")
parser.add_option('--chunksize',default=1,
                  help="jackknife chunk size, number of pairs")
parser.add_option('--progress',action='store_true',
                  help="show progress during jackknifing")


parser.add_option('--zero-run',default=None,
                  help="zero run to use for W matrix")
parser.add_option('--is-zero',action='store_true',
                  help="this is a zero shear run for pqrs")

parser.add_option('--skip-pqr',action='store_true',
                  help="don't do pqr")

parser.add_option('--show',action='store_true',
                  help="show some plots")



CHUNKSIZE=1000000

simple_models=['exp','dev','gauss']

def get_dtype(fobj, model, options):

    data = fobj[1][0:10]

    names=data.dtype.names

    dt =data.dtype.descr
    dt += [('s2n_matched','f8'),
           ('nsum','i8'),
           ('s2n_w_sum','f8'),
           ('g_sum','f8',2),
           ('g_sens_sum','f8',2),
           ('shear','f8',2),
           ('shear_cov','f8',(2,2)),
           ('shear_cov_inv_sum','f8',(2,2)),
           ('P_sum','f8'),
           ('Q_sum','f8',2),
           ('Cinv_sum','f8',(2,2))]

    if 'S' in data.dtype.names:
        if options.is_zero:
            # this is a zero-shear run
            dt += [('Wsum','f8',(6,6))]
        else:
            mess="you must send a zero-run when doing pqrs shear"
            assert options.zero_run is not None,mess
            dt += [('Usum','f8',6),
                   ('shear_pqrs','f8',2)]

    dt += [('shear_lensfit','f8',2),
           ('shear_lensfit_cov','f8',(2,2)),
           ('shear_lensfit_cov_inv_sum','f8',(2,2)),
          ]


    if model in simple_models or model =='bdf':
        dt += [('flux_sum','f8'),
               ('flux_err2invsum','f8'),
               ('flux_s2n_sum','f8'),
               ('flux','f8'),
               ('flux_err','f8'),
               ('flux_s2n','f8'),

               ('T_sum','f8'),
               ('T_err2invsum','f8'),
               ('T_s2n_sum','f8'),
               ('T','f8'),
               ('T_err','f8'),
               ('T_s2n','f8')]

    return dt

def get_chunk_info(nrows):
    nchunks=nrows//CHUNKSIZE

    remain = nrows % CHUNKSIZE
    if remain > 0:
        nchunks += 1

    return nchunks

def get_lensfit_stats(conf, data, options):

    t0=time.time()

    npair=data.size/2
    chunksize = npair/1000

    if chunksize < 1:
        chunksize=1
    #elif chunksize > 100:
    #    chunksize=100

    print('    jackknife lensfit chunksize:',chunksize)

    shear, shear_cov, g_sum, gsens_sum = \
            ngmix.lensfit.lensfit_jackknife(data['g'], data['g_sens'],
                                            progress=options.progress,
                                            chunksize=chunksize,
                                            get_sums=True,
                                            show=options.show)

    tm=time.time()-t0

    return shear, shear_cov, g_sum, gsens_sum


def get_shear_stats(conf, data, options):

    P_sum, Q_sum, Cinv_sum = ngmix.pqr.calc_pqr_sums(data['P'],
                                                     data['Q'],
                                                     data['R'])


    if options.jackknife:
        t0=time.time()

        npair=data.size/2
        chunksize = npair/1000
        #if chunksize > 100:
        #    chunksize=100
        #else:
        #    chunksize=1

        if chunksize < 1:
            chunksize=1
        elif chunksize > 100:
            chunksize=100
        print('    jackknife pqr chunksize:',chunksize)

        shear, shear_cov = \
                ngmix.pqr.pqr_jackknife(data['P'],data['Q'],data['R'],
                                        progress=options.progress,
                                        chunksize=chunksize,
                                        eps=conf['eps'])

        tm=time.time()-t0

        shear_cov_inv = numpy.linalg.inv(shear_cov)
        w=numpy.arange(data.size)

    elif options.pqr_cov:
        # no ring
        shear_cov_inv = Cinv_sum.copy()
        w=numpy.arange(data.size)
    else:
        names=data.dtype.names
        if 'g_cov' in names:
            cov = data['g_cov']
        else:
            cov = data['pcov'][:,2:2+2, 2:2+2]

        cov_inv = cov.copy()

        det = cov[:,0,0]*cov[:,1,1] - cov[:,0,1]*cov[:,1,0]
        cov_inv[:,0,0] = cov[:,1,1]
        cov_inv[:,1,1] = cov[:,0,0]
        cov_inv[:,0,1] = - cov[:,0,1]
        cov_inv[:,1,0] = - cov[:,1,0]

        w,=numpy.where( det > 0 )
        idet = numpy.zeros(det.size)
        idet[w] = 1.0/det[w]
        cov_inv[:,0,0] *= idet
        cov_inv[:,0,1] *= idet
        cov_inv[:,1,0] *= idet
        cov_inv[:,1,1] *= idet

        shear_cov_inv = cov_inv.sum(axis=0)


    return P_sum, Q_sum, Cinv_sum, shear_cov_inv, w


def add_more_sums(conf, data, d, w):

    model=conf['fit_model']

    d['s2n_w_sum'][0] += data['s2n_w'].sum()

    if model in simple_models or model=='bdf':
        flux     = data['pars'][:,5:].sum(axis=1)
        flux_var = data['pcov'][:,5:,5:].sum(axis=1).sum(axis=1)

        flux_err = sqrt(flux_var)

        d['flux_sum'][0]        += flux.sum()

        d['flux_err2invsum'][0] += (1.0/flux_var[w]).sum()

        flux_s2n_vals = flux/flux_err
        d['flux_s2n_sum'][0] += flux_s2n_vals.sum()

        T=data['pars'][:,4]
        T_var=data['pcov'][:,5,5]
        T_err=sqrt(T_var)

        # these are for getting the overall mean T not the mean
        # s2n; that is below
        d['T_sum'][0] += T.sum()
        d['T_err2invsum'][0] += (1.0/T_var[w]).sum()

        T_s2n_vals = T/T_err
        d['T_s2n_sum'][0] += T_s2n_vals.sum()

def add_pqrs_stats(conf, data, d, options):
    if options.is_zero:
        Wsum= ngmix.pqr.make_Wsum(data['P'],
                                  data['Q'],
                                  data['S'])

        import images
        images.imprint(Wsum,fmt='%15g')
        d['Wsum'][0,:,:] = Wsum
    else:
        d['Usum'][0,:] = ngmix.pqr.make_Usum(data['P'],
                                             data['Q'],
                                             data['S'])

        zd=conf['zero_data']
        W = zd['Wsum'][0]/zd['nsum'][0]
        print(W)
        Winv = numpy.linalg.inv(W)
        U = d['Usum'][0]/d['nsum'][0]

        res=numpy.dot(Winv, U)

        d['shear_pqrs'][0,:] = res[0:0+2]


def do_sums(conf, data, d, options):
    d['nsum'][0] += data.size

    if not options.skip_pqr:
        P_sum, Q_sum, Cinv_sum, shear_cov_inv, w = \
                get_shear_stats(conf, data, options)


        d['P_sum'][0] += P_sum
        d['Q_sum'][0] += Q_sum
        d['Cinv_sum'][0] += Cinv_sum

        if 'S' in data.dtype.names:
            add_pqrs_stats(conf, data, d, options)

        d['shear_cov_inv_sum'][0] += shear_cov_inv
    else:
        w=numpy.arange(data.size)

    sh_lf, shcov_lf, g_sum, gsens_sum = get_lensfit_stats(conf, data, options)
    d['g_sum'][0] += g_sum
    d['g_sens_sum'][0] += gsens_sum

    shcov_lf_inv = numpy.linalg.inv(shcov_lf)
    d['shear_lensfit_cov_inv_sum'][0] += shcov_lf_inv

    add_more_sums(conf, data, d, w,)

def do_avg(conf, d, options):

    shtrue=conf['simc']['shear'][0]

    model=conf['fit_model']

    d['s2n_w'][0] = d['s2n_w_sum'][0]/d['nsum'][0]

    if not options.skip_pqr:
        #
        # pqr
        #
        shear_cov = numpy.linalg.inv(d['shear_cov_inv_sum'][0,:,:])

        C = numpy.linalg.inv(d['Cinv_sum'][0,:,:])
        Q_sum = d['Q_sum'][0,:]
        shear = numpy.dot(C,Q_sum)


        # did we expand around the true shear?
        expand_shear=conf.get('expand_shear_true',False)
        if expand_shear:
            true_shear = numpy.array( conf['simc']['shear'] )
            print('adding expand shear:',true_shear)
            shear += true_shear

        d['shear'][0] = shear
        d['shear_cov'][0,:,:] = shear_cov

        sherr=numpy.sqrt(shear_cov[0,0])
        fracdiff=shear[0]/shtrue-1.0
        fracdiff_err=sherr/shtrue
        print('fracdiff(pqr):     %.2g +/- %.2g' % (fracdiff, fracdiff_err))

    #
    # lensfit
    # 

    shlf = d['g_sum'][0]/d['g_sens_sum'][0]

    d['g_sens'] = d['g_sens_sum'][0]/d['nsum'][0]
    d['shear_lensfit'][0] = shlf
    d['shear_lensfit_cov'][0] = numpy.linalg.inv(d['shear_lensfit_cov_inv_sum'][0])

    sherrlf=numpy.sqrt(d['shear_lensfit_cov'][0,0,0])

    fracdiff=shlf[0]/shtrue-1.0
    fracdiff_err=sherrlf/shtrue

    print('fracdiff(lensfit): %.2g +/- %.2g' % (fracdiff, fracdiff_err))

    if model in simple_models or model=='bdf':
        d['flux'] = d['flux_sum']/d['nsum']
        d['flux_err'] = sqrt(1.0/d['flux_err2invsum'])
        d['flux_s2n'] = d['flux_s2n_sum']/d['nsum']
        d['T'] = d['T_sum']/d['nsum']
        d['T_err'] = sqrt(1.0/d['T_err2invsum'])
        d['T_s2n'] = d['T_s2n_sum']/d['nsum']

def get_jackknife_eps(fname):
    dirname=os.path.dirname(fname)
    bname=os.path.basename(fname)

    pdir = dirname.replace('outputs','plots')
    if not os.path.exists(pdir):
        os.makedirs(pdir)

    jname=bname.replace('.fits','-jackknife.eps')

    jname = os.path.join(pdir, jname)
    return jname

def do_sums_jackknife(conf, fobj, d, options):
    # we can't do jackknifing by chunks

    data = fobj[1][:]
    data=select(conf, data)

    conf['eps']=get_jackknife_eps(conf['fname'])
    do_sums(conf, data, d, options)

def do_sums_bychunk(conf, fobj, d, options):
    nrows=fobj[1].get_nrows()
    nchunks = get_chunk_info(nrows)

    for i in xrange(nchunks):
        beg = i*CHUNKSIZE
        end = (i+1)*CHUNKSIZE
        print('    %s:%s of %s' % (beg,end,nrows))
        data = fobj[1][beg:end]

        data=select(conf, data)

        do_sums(conf, data, d, options)

def select(conf, data):

    logic = numpy.ones(data.size, dtype=bool)
    docut=False
    if 'avg_min_arate' in conf:
        print("    selecting arate >",conf['avg_min_arate'])
        logic = logic & (data['arate'] > conf['avg_min_arate'])
        docut=True

    if 'avg_min_Ts2n' in conf:
        if conf['use_logpars']:
            print("       Ts2n for logpars")
            Ts2n = 1.0/sqrt( data['pcov'][:,4,4] )
        else:
            Ts2n = data['pars'][:,4]/sqrt( data['pcov'][:,4,4] )

        print("    selecting Ts2n >",conf['avg_min_Ts2n'])
        logic = logic & (Ts2n > conf['avg_min_Ts2n'])
        #logic = logic & (Ts2n > conf['avg_min_Ts2n']) & (Ts2n < 15)
        docut=True

    if 'avg_min_neff' in conf:
        print("    selecting neff >",conf['avg_min_neff'])
        logic = logic & (data['neff'] > conf['avg_min_neff'])
        docut=True

    if 'avg_min_fracuse' in conf:
        print("    selecting fracuse >",conf['avg_min_fracuse'])
        logic = logic & (data['fracuse'] > conf['avg_min_fracuse'])
        docut=True



    if docut:
        no_ring=conf['simc'].get('no_ring',False)

        if no_ring:
            w,=numpy.where(logic)
        else:
            print("        pairing for ring")

            w=nsim.util.ring_select(logic)
        
        frac=float(w.size)/data.size
        print("        keeping %d/%d  %.3f" % (w.size,data.size,frac))
        data=data[w]

    return data

def get_averaged(conf, s2n_matched, options):

    model=conf['fit_model']

    print(conf['fname'])
    with fitsio.FITS(conf['fname']) as fobj:

        dt= get_dtype(fobj,model,options)

        d=numpy.zeros(1, dtype=dt)
        d['s2n_matched'] = s2n_matched

        if options.jackknife:
            do_sums_jackknife(conf, fobj, d, options)
        else:
            do_sums_bychunk(conf, fobj, d, options)

    do_avg(conf, d, options)

    return d


def main():
    options,args = parser.parse_args(sys.argv[1:])

    if len(args) < 2:
        parser.print_help()
        sys.exit(45)


    run=args[0]
    is2n=int(args[1])

    if options.skip is None:
        skip=[]
    else:
        skip = [int(v) for v in options.skip.split(',')]

    c = nsim.files.read_config(run)
    c['simc'] = nsim.files.read_config(c['sim'])

    s2n_vals    = c['s2n_vals']

    s2n_matched = s2n_vals[is2n]
    c['fname']=nsim.files.get_output_url(run, 0, is2n)

    if options.zero_run is not None:
        c['zero_data']=nsim.files.read_averaged(options.zero_run, is2n=is2n)

    output = get_averaged(c, s2n_matched, options)

    out_fname=nsim.files.get_averaged_url(run, is2n=is2n)
    print('writing:',out_fname)
    fitsio.write(out_fname, output, clobber=True)


main()
