#!/usr/bin/env python
from __future__ import print_function
import sys
import os
import numpy
from numpy import sqrt, array, diag, ones, zeros, where, newaxis
from numpy import newaxis
import biggles

import fitsio

import ngmix
import nsim
from nsim import files

import argparse
import esutil as eu
from esutil.numpy_util import between


fclass=argparse.ArgumentDefaultsHelpFormatter
parser=argparse.ArgumentParser(formatter_class=fclass)

parser.add_argument('run', help='run to use in fit')

parser.add_argument('--weights',action='store_true')
parser.add_argument('--s2n-soft',type=float,default=20)
parser.add_argument('--cuts',action='store_true')

parser.add_argument('--show',action='store_true',help='show plot')
parser.add_argument('--sub-offset',action='store_true',help='subtract the offset')
parser.add_argument('--yrange', help="yrange of plot")
parser.add_argument('--xrange', help="xrange of plot")

parser.add_argument('--fit-only',action='store_true',
                    help='get the means from the written file')

parser.add_argument('--cache',action='store_true',
                    help=('cache the file subset locally; use the cache '
                          'if available'))


default_columns=[
    'shear_index',
    'mcal_g',
    'mcal_gpsf',
    'mcal_R',
    'mcal_Rpsf',
    'mcal_dt_Rnoise',
    #'mcal_dt_Rnoise_psf',
]


def read_data(conf, args, cache=False, columns=default_columns):

    if cache:
        return read_cached_data(conf,args)


    if args.cuts:
        print("making cuts")
        print("reading cut fields only")
        t=nsim.files.read_output(conf['run'],
                                 0,
                                 columns=['mcal_s2n_r','mcal_R'])
        w,=numpy.where(
            between(t['mcal_s2n_r'], 6.3, 3162.)
            & between(t['mcal_R'][:,0,0], -6.0, 2.0)
            & between(t['mcal_R'][:,0,1], -5.0, 5.0)
            & between(t['mcal_R'][:,1,0], -5.0, 5.0)
            & between(t['mcal_R'][:,1,1], -6.0, 2.0)
        )
        print("    kept: %d/%d" % (w.size,t.size))
        print("reading subset")
        print("reading columns:",columns)
        return nsim.files.read_output(conf['run'], 0, columns=columns, rows=w)
    else:
        print("reading columns:",columns)
        return nsim.files.read_output(conf['run'], 0, columns=columns)#,
                                      #rows=numpy.arange(10000000))


    '''
    chunksize=1000000
    fname=files.get_output_url(conf['run'], 0, 0)
    with fitsio.FITS(fname) as fits:
        hdu = fits[1]
        nrows=hdu.get_nrows()

        data=numpy.zeros(nrows, dtype=dt)

        nchunks = nrows//chunksize

        if (nrows % chunksize) > 0:
            nchunks += 1

        beg=0
        for i in xrange(nchunks):

            end=beg+chunksize

            tdata = hdu[columns][beg:end]

            data['shear_index'][beg:beg+tdata.size] = tdata['shear_index']
            data['gpsf'][beg:beg+tdata.size] = tdata['mcal_gpsf']

            data['g'][beg:beg+tdata.size] = tdata['mcal_g'][:,:]
            data['R'][beg:beg+tdata.size] = tdata['mcal_R'][:,:,:]
            data['Rpsf'][beg:beg+tdata.size] = tdata['mcal_Rpsf'][:,:]

            beg += tdata.size

    return data
    '''

def get_cache_file(conf):
    tdir=os.environ['TMPDIR']
    tfile= nsim.files.get_output_url(conf['run'], 0, 0)
    tfile=os.path.basename(tfile)

    tfile=os.path.join(tdir, tfile)
    return tfile

def read_cached_data(conf, args):

    tfile=get_cache_file(conf)

    if os.path.exists(tfile):
        print("reading cache:",tfile)

        columns=default_columns
        if args.weights:
            columns.append('mcal_s2n_r')
        print("reading columns:",columns)
        data=fitsio.read(tfile,columns=columns)

    else:
        columns = default_columns
        columns.append('mcal_s2n_r')
        data=read_data(conf,args, columns=columns)
        print("writing cache:",tfile)
        fitsio.write(tfile, data, clobber=True)

    return data


SIGMA2_MIN_CONSTANT_GROUND = 4.     # 2**2
NORMALIZATION_CONSTANT_SPACE = 1.232
NORMALIZATION_CONSTANT_GROUND = NORMALIZATION_CONSTANT_SPACE

CFID = 2.e-4
MFID = 2.e-3

def fitpoly(noise0, noises, Rdiff, Rdiff_err):
    fitter=Fitter(noise0, noises, Rdiff, Rdiff_err)
    fitter.dofit()
    #print(fitter)
    if False:
        fitter.plot(show=True)
        if raw_input('hit a key: ')=='q':
            stop

    res=fitter.get_result()
    return res

def fitpolyold(n0, noises, R0, R0err, Rnoise, Rnoise_err):
    ntot = noises.size + 1

    noise_tot = zeros(ntot)
    noise_tot[0] = n0
    noise_tot[1:] = noises

    Rtot = zeros(ntot)
    Rtot_err = zeros(ntot)
    Rtot[0] = R0
    Rtot[1:] = Rnoise
    Rtot_err[0] = R0err
    Rtot_err[1:] = Rnoise_err
    
    if True:
        biggles.plot(noise_tot, Rtot)
        stop

    fitter=Fitter(noise_tot, Rtot, Rtot_err)
    fitter.dofit()
    print(fitter)

    res=fitter.get_result()
    R = res['pars'][0]
    Rerr = res['perr'][0]

    return R, Rerr


class Fitter(object):
    def __init__(self, x0, x, y, yerr):

        self.x0=x0
        self.x=x

        self.xdiff=x-x0
        self.x2diff=x**2 - x0**2
        self.y=y
        self.yerr=yerr

        self.npars=2

        self._set_guess()

    def get_result(self):
        return self._result

    def dofit(self):
        from scipy.optimize import leastsq
        res=leastsq(self._errfunc, self.guess, full_output=1)

        pars, pcov0, infodict, errmsg, ier = res
        if ier == 0:
            # wrong args, this is a bug
            raise ValueError(errmsg)

        numiter = infodict['nfev']
        pcov=None
        perr=None

        if pcov0 is not None:
            pcov = self._scale_leastsq_cov(pars, pcov0)

            d=numpy.diag(pcov)
            w,=numpy.where(d < 0)

            if w.size == 0:
                # only do if non negative
                perr = numpy.sqrt(d)

        self._result={'pars':pars, 'pcov':pcov, 'perr':perr,'errmsg':errmsg}


    def _set_guess(self):
        """
        [a, b]
        a (x^2 - x0^2) + b (x-x0)
        """
        self.guess = array([-0.1, 0.1])

    def eval_pars(self, pars, x=None):
        """
        [a, b]
        a (x^2 - x0^2) + b (x-x0)
        """

        if x is not None:
            xdiff=x-self.x0
            x2diff=x**2 - self.x0**2
        else:
            xdiff=self.xdiff
            x2diff=self.x2diff

        return pars[0]*x2diff + pars[1]*xdiff

    def _errfunc(self, pars):
        model = self.eval_pars(pars)
        diff = (model-self.y)/self.yerr
        return diff.ravel()

    def _scale_leastsq_cov(self, pars, pcov):
        """
        Scale the covariance matrix returned from leastsq; this will
        recover the covariance of the parameters in the right units.
        """

        # is total size right here?
        dof = (self.y.size-len(pars))
        s_sq = (self._errfunc(pars)**2).sum()/dof
        return pcov * s_sq 

    def plot(self, show=False):
        import biggles
        pars=self._result['pars']
        perr=self._result['perr']

        x=numpy.linspace(self.x0, self.x.max(),100)
        x2diff=x**2 - self.x0**2
        yfit = self.eval_pars(pars, x=x)

        plt=biggles.FramedPlot()

        pts=biggles.Points(self.x2diff, self.y)
        err=biggles.SymmetricErrorBarsY(self.x2diff, self.y, self.yerr)

        c=biggles.Curve(x2diff, yfit, type='solid', color='blue')

        plt.add(c, pts, err)

        alab=r'$A = %.3g \pm %.3g' % (pars[0], perr[0])
        blab=r'$B = %.3g \pm %.3g' % (pars[1], perr[1])
        alabel=biggles.PlotLabel(0.9, 0.9, alab, halign='right')
        blabel=biggles.PlotLabel(0.9, 0.85, blab, halign='right')

        plt.add(alabel, blabel)

        if show:
            plt.show()
        return plt



    def __repr__(self):
        if hasattr(self,'_result'):
            pars=self._result['pars']
            perr=self._result['perr']

            rep = """
    a (x^2-x0^2) + b (x-x0)
    a: %g +/- %g
    b: %g +/- %g\n""" % (pars[0],perr[0],pars[1],perr[1])

        return rep



class FitterOld(object):
    def __init__(self, x, y, yerr):

        self.x=x

        self.xsq=x**2
        self.diffx = x - x[0]

        self.y=y
        self.yerr=yerr

        self.npars=2

        self._set_guess()

    def get_result(self):
        return self._result

    def dofit(self):
        from scipy.optimize import leastsq
        res=leastsq(self._errfunc, self.guess, full_output=1)

        pars, pcov0, infodict, errmsg, ier = res
        if ier == 0:
            # wrong args, this is a bug
            raise ValueError(errmsg)

        numiter = infodict['nfev']
        pcov=None
        perr=None

        if pcov0 is not None:
            pcov = self._scale_leastsq_cov(pars, pcov0)

            d=numpy.diag(pcov)
            w,=numpy.where(d < 0)

            if w.size == 0:
                # only do if non negative
                perr = numpy.sqrt(d)

        self._result={'pars':pars, 'pcov':pcov, 'perr':perr}


    def _set_guess(self):
        """
        [R, a, b]
        R +  a (x-x0) + b x^2
        """
        self.guess = array([0.5, 0.1, -0.1])

    def eval_pars(self, pars):
        """
        [R, a, b]
        R +  a (x-x0) + b x^2
        """

        return pars[0] + pars[1]*self.diffx + pars[2]*self.xsq

    def _errfunc(self, pars):
        model = self.eval_pars(pars)
        diff = (model-self.y)/self.yerr
        return diff.ravel()

    def _scale_leastsq_cov(self, pars, pcov):
        """
        Scale the covariance matrix returned from leastsq; this will
        recover the covariance of the parameters in the right units.
        """

        # is total size right here?
        dof = (self.x.size-len(pars))
        s_sq = (self._errfunc(pars)**2).sum()/dof
        return pcov * s_sq 

    def __call__(self, x):
        """
        pars order same as for numpy.poly1d
        """
        return self.eval_pars(self._result['pars'])

    def __repr__(self):
        if hasattr(self,'_result'):
            pars=self._result['pars']
            perr=self._result['perr']

            rep = """
    R + a dx + b x^2
    R: %g +/- %g
    a: %g +/- %g
    b: %g +/- %g\n""" % (pars[0],perr[0],pars[1],perr[1],pars[2],perr[2])

        return rep



# quick line fit pulled from great3-public code
def _calculateSvalues(xarr, yarr, sigma2=1.):
    """Calculates the intermediate S values required for basic linear regression.

    See, e.g., Numerical Recipes (Press et al 1992) Section 15.2.
    """
    if len(xarr) != len(yarr):
        raise ValueError("Input xarr and yarr differ in length!")
    if len(xarr) <= 1:
        raise ValueError("Input arrays must have 2 or more values elements.")

    S = len(xarr) / sigma2
    Sx = numpy.sum(xarr / sigma2)
    Sy = numpy.sum(yarr / sigma2)
    Sxx = numpy.sum(xarr * xarr / sigma2)
    Sxy = numpy.sum(xarr * yarr / sigma2)
    return (S, Sx, Sy, Sxx, Sxy)

def fitline(xarr, yarr):
    """Fit a line y = a + b * x to input x and y arrays by least squares.

    Returns the tuple (a, b, Var(a), Cov(a, b), Var(b)), after performing an internal estimate of
    measurement errors from the best-fitting model residuals.

    See Numerical Recipes (Press et al 1992; Section 15.2) for a clear description of the details
    of this simple regression.
    """
    # Get the S values (use default sigma2, best fit a and b still valid for stationary data)
    S, Sx, Sy, Sxx, Sxy = _calculateSvalues(xarr, yarr)
    # Get the best fit a and b
    Del = S * Sxx - Sx * Sx
    a = (Sxx * Sy - Sx * Sxy) / Del
    b = (S * Sxy - Sx * Sy) / Del
    # Use these to estimate the sigma^2 by residuals from the best-fitting model
    ymodel = a + b * xarr
    sigma2 = numpy.mean((yarr - ymodel)**2)
    # And use this to get model parameter error estimates
    var_a  = sigma2 * Sxx / Del
    cov_ab = - sigma2 * Sx / Del
    var_b  = sigma2 * S / Del

    a_err = numpy.sqrt(var_a)
    b_err = numpy.sqrt(var_b)

    return {'offset':a,
            'offset_err':a_err,
            'slope':b,
            'slope_err':b_err,
            'cov':cov_ab}
    #return a, a_err, b, b_err, cov_ab

def fitline_zero_offset(x, y):

    # Our model is y = a * x, so things are quite simple, in this case...
    # x needs to be a column vector instead of a 1D vector for this, however.
    x = x[:,numpy.newaxis]
    a, _, _, _ = numpy.linalg.lstsq(x, y)

    return {'offset':0.0,
            'offset_err':0.0,
            'slope':a[0],
            'slope_err':0.0}
    
def calc_q(fits):

    m1=fits['m'][0,0]
    m2=fits['m'][0,1]
    c1=fits['c'][0,0]
    c2=fits['c'][0,1]

    sigma2_min = SIGMA2_MIN_CONSTANT_GROUND 
    norm = NORMALIZATION_CONSTANT_GROUND 

    num = 2000.0 * norm
    denom = numpy.sqrt(  (c1 / CFID)**2 
                       + (c2 / CFID)**2
                       + (m1 / MFID)**2
                       + (m2 / MFID)**2
                       + sigma2_min)

    Q = num/denom
    
    print("  Q: %g" % Q)

    return Q

def doplot(args, data, fits):
    import biggles

    Q=calc_q(fits)

    if args.yrange is not None:
        yrange=[float(r) for r in args.yrange.split(',')]
    else:
        yrange=[-0.01,0.01]

    xrng=args.xrange
    if xrng is not None:
        xrng=[float(r) for r in args.xrange.split(',')]

    tab=biggles.Table(1,2)
    tab.aspect_ratio=0.5

    diff = data['shear'] - data['shear_true']

    plts=[]
    for i in [0,1]:

        x = data['shear_true'][:,i]
        plt =biggles.plot(
            x,
            diff[:,i],
            xlabel='shear%d true' % (i+1,),
            ylabel='shear%d diff' % (i+1,),
            yrange=yrange,
            xrange=xrng,
            visible=False,
        )
        yfit=fits['m'][0,i]*x + fits['c'][0,i]

        z=biggles.Curve(x, x*0, color='black')
        c=biggles.Curve(x, yfit, color='red')
        plt.add(z,c)

        mstr='m%d: %.2g +/- %.2g' % (i+1,fits['m'][0,i],fits['merr'][0,i])
        cstr='c%d: %.2g +/- %.2g' % (i+1,fits['c'][0,i],fits['cerr'][0,i])
        mlab=biggles.PlotLabel(0.1,0.9,
                               mstr,
                               halign='left')
        clab=biggles.PlotLabel(0.1,0.85,
                               cstr,
                               halign='left')
        plt.add(mlab,clab)
        if i==0:
            Qstr='Q: %d' % (int(Q),)
            Qlab=biggles.PlotLabel(0.1,0.8,
                                   Qstr,
                                   halign='left')
            plt.add(Qlab)


        tab[0,i] = plt

    #fname=reredux.files.get_fit_file(args.run,
    #                                 extra='fit-m-c',
    #                                 ext='eps')
    #eu.ostools.makedirs_fromfile(fname)
    #print("writing:",fname)
    #tab.write_eps(fname)

    if args.show:
        tab.show(width=1000, height=1000)

def write_fits(args, fits):
    fname=reredux.files.get_fit_file(args.run, extra='fit-m-c')

    eu.ostools.makedirs_fromfile(fname)
    print("writing fit data to file:",fname)
    fitsio.write(fname, fits, clobber=True)

def get_mean_struct(n):
    dt=[('shear','f8',2),
        ('shear_true','f8',2),
        ('shear_err','f8',2)]

    means = numpy.zeros(n, dtype=dt)
    return means

def read_means(args):
    return reredux.files.read_fit_file(args.run,
                                       extra='shear-means')
def write_means(args, means):
    fname=reredux.files.get_fit_file(args.run,
                                     extra='shear-means')
    eu.ostools.makedirs_fromfile(fname)

    print("writing:",fname)
    fitsio.write(fname, means, clobber=True)


def print_shear(ind, num, shear, shear_err):
    mess="  %d: %d  %g +/- %g  %g +/- %g"
    tup=(ind, num, shear[0],shear_err[0], shear[1],shear_err[1])
    print(mess % tup)

def get_averages(conf, args, data, show_progress=True):

    if args.weights:
        return get_averages_weighted(conf, args, data,
                                     show_progress=show_progress)

    sconf=conf['simc']
    shears = sconf['shear']['shears']

    h,rev = eu.stat.histogram(data['shear_index'], rev=True)
    nind = h.size

    g=data['mcal_g']
    gpsf=data['mcal_gpsf']

    R=data['mcal_R']
    Rpsf=data['mcal_Rpsf']

    #Rnoise, Rnoise_psf = get_Rnoise_line(conf, args, data)
    Rnoise = get_Rnoise_line(conf, args, data)

    Rmean = R.mean(axis=0)
    Rpsf_mean = Rpsf.mean(axis=0)

    Rmean -= Rnoise
    #Rpsf_mean -= Rnoise_psf
    Rinv = numpy.linalg.inv(Rmean)

    means=get_mean_struct(nind)

    for i in xrange(nind):
        if show_progress:
            print("shear index:",i)

        w=rev[ rev[i]:rev[i+1] ]

        shear_true = shears[i]

        psf_corr  = (gpsf[w]*Rpsf_mean).mean(axis=0)

        gmean     = g[w].mean(axis=0)
        shear     = numpy.dot(Rinv, gmean-psf_corr)
        shear_err = g[w].std(axis=0)/numpy.sqrt(w.size)
        shear_err = numpy.dot(Rinv, shear_err)

        means['shear'][i] = shear
        means['shear_err'][i] = shear_err
        means['shear_true'][i] = shear_true

    return means

def get_averages_weighted(conf, args, data, show_progress=True):

    print("using weights")
    weights=get_s2n_weights(data['mcal_s2n_r'], args)
    wsum=weights.sum()
    #wna1=weights[:,newaxis]
    #wna2=weights[:,newaxis,newaxis]

    sconf=conf['simc']
    shears = sconf['shear']['shears']

    h,rev = eu.stat.histogram(data['shear_index'], rev=True)
    nind = h.size

    g=data['mcal_g']
    gpsf=data['mcal_gpsf']

    R=data['mcal_R']
    Rpsf=data['mcal_Rpsf']

    print("getting Rnoise")
    #Rnoise, Rnoise_psf = get_Rnoise_line(conf, args, data, weights=weights)
    Rnoise = get_Rnoise_line(conf, args, data, weights=weights)

    print("calculating Rmean")
    Rmean = numpy.zeros( (2,2) )
    Rpsf_mean = numpy.zeros(2)
    for i in xrange(2):
        Rpsf_mean[i] = (Rpsf[:,i]*weights).sum()/wsum
        for j in xrange(2):
            Rmean[i,j] = (R[:,i,j]*weights).sum()/wsum

    Rmean = Rmean - Rnoise
    #Rpsf_mean = Rpsf_mean - Rnoise_psf

    Rinv = numpy.linalg.inv(Rmean)

    means=get_mean_struct(nind)

    print("getting shears for each shear_index")
    gmean=numpy.zeros(2)
    psf_corr=numpy.zeros(2)
    for i in xrange(nind):
        if show_progress:
            print("shear index:",i)

        w=rev[ rev[i]:rev[i+1] ]

        shear_true = shears[i]

        twsum = weights[w].sum()
        for j in xrange(2):
            psf_corr[j]  = Rpsf_mean[j]*(gpsf[w,j]*weights[w]).sum()/twsum
            gmean[j]     = (g[w,j]*weights[w]).sum()/twsum

        shear = numpy.dot(Rinv, gmean-psf_corr)

        # wrong, but won't get used anyway
        shear_err = g[w].std(axis=0)/numpy.sqrt(w.size)
        shear_err = numpy.dot(Rinv, shear_err)

        means['shear'][i] = shear
        means['shear_err'][i] = shear_err
        means['shear_true'][i] = shear_true

    return means


def print_m_c(sindex, m, merr, c, cerr, r=None):
    fmt = '  m{i}: %.3e +/- %.3e c{i}: %.3e +/- %.3e'.format(i=sindex)
    if r is not None:
        fmt += '  r{i}: %.3g'.format(i=sindex)
        print(fmt % (m, merr, c, cerr,r))
    else:
        print(fmt % (m, merr, c, cerr))

def fit_m_c(data, doprint=True):
    import fitting
    import mcmc
    import esutil as eu

    strue = data['shear_true']
    sdiff = data['shear'] - data['shear_true']

    m = numpy.zeros(2)
    merr = numpy.zeros(2)
    c = numpy.zeros(2)
    cerr = numpy.zeros(2)

    fits=numpy.zeros(1, dtype=[('m','f8',2),
                               ('merr','f8',2),
                               ('c','f8',2),
                               ('cerr','f8',2),
                               ('r','f8',2)])
    for i in [0,1]:
        res = fitline(strue[:,i], sdiff[:,i])
        r = res['cov']/sqrt(res['slope_err']**2 * res['offset_err']**2)
        fits['m'][0,i] = res['slope']
        fits['merr'][0,i] = res['slope_err']
        fits['c'][0,i] = res['offset']
        fits['cerr'][0,i] = res['offset_err']
        fits['r'][0,i] = r

        if doprint:
            print_m_c(i+1, res['slope'],res['slope_err'],
                      res['offset'],res['offset_err'], r=r)

    return fits

def correct_means(conf, all_means, args):
    import fitting

    noise0 = conf['noise']
    target_noises = numpy.array( conf['target_noises'] )

    noises2 = numpy.zeros(1+target_noises.size)
    noises2[0] = conf['noise']**2
    noises2[1:] = target_noises**2


    ratio = numpy.ones( (noises2.size, 2) )
    ratio_err = numpy.ones( (noises2.size, 2) )
    for i in xrange(0,noises2.size):

        offset1,oerr,slope1,s1err,cov=fitline(all_means[0]['shear'][:,0],all_means[i]['shear'][:,0])
        offset2,oerr,slope2,s2err,cov=fitline(all_means[0]['shear'][:,1],all_means[i]['shear'][:,1])

        print("-"*70)
        print("  s1 %d: %g + %g * s1(0)" % (i,offset1,slope1))
        print("  s2 %d: %g + %g * s2(0)" % (i,offset2,slope2))

        ratio[i,:] = slope1,slope2
        ratio_err[i,:] = s1err,s2err

    print("-"*70)
    ratio_err[0,:] = ratio_err[1,:]


    offset1,oerr,slope1,serr,cov=fitline(noises2[1:], ratio[1:,0]) 
    offset2,oerr,slope2,serr,cov=fitline(noises2[1:], ratio[1:,1]) 

    print("fit g1")
    print("%g + %g * g1" % (offset1,slope1))
    print("fit g2")
    print("%g + %g * g2" % (offset2,slope2))

    new_means=all_means[0].copy()
    new_means['shear'][:,0] *= offset1
    new_means['shear'][:,1] *= offset2
    new_means['shear_err'][:,0] *= offset1
    new_means['shear_err'][:,1] *= offset2

    if args.show:
        import biggles
        xrng=[0, 1.1*noises2.max()]
        plt=biggles.plot(noises2, ratio[:,0], yerr=ratio_err[:,0],
                         color='blue',visible=False,
                         xlabel='noise**2',
                         ylabel='<shear/shear0>',
                         xrange=xrng)
        plt=biggles.plot(noises2, ratio[:,1], yerr=ratio_err[:,1],
                         color='red',visible=False,
                         plt=plt)

        xvals=numpy.linspace(0, xrng[1])
        yvals1 = offset1 + slope1*xvals
        yvals2 = offset2 + slope2*xvals
        plt.add(biggles.Curve(xvals,yvals1,color='blue',type='solid'))
        plt.add(biggles.Curve(xvals,yvals2,color='red',type='solid'))

        plt.show()

    return new_means

def get_R_poly_old(conf, args, data):
    import fitting


    noise0 = conf['noise']
    target_noises = numpy.array( conf['target_noises'] )

    diff_noise = target_noises - noise0
    diff_noise2 = target_noises**2 - noise0**2

    n=data.size

    R0 = data['mcal_R'].mean(axis=0)
    R0_err = data['mcal_R'].std(axis=0)/sqrt(n)
    Rpsf0 = data['mcal_Rpsf'].mean(axis=0)
    Rpsf0_err = data['mcal_Rpsf'].std(axis=0)/sqrt(n)

    Rdt = data['mcal_dt_Rnoise'].mean(axis=0)
    Rdt_err = data['mcal_dt_Rnoise'].std(axis=0)/sqrt(n)
    Rdt_psf = data['mcal_dt_Rnoise_psf'].mean(axis=0)
    Rdt_psf_err = data['mcal_dt_Rnoise_psf'].std(axis=0)/sqrt(n)

    R = zeros( (2,2) )
    R_err = zeros( (2,2) )
    Rpsf = zeros(2)
    Rpsf_err = zeros(2)
    
    for i in xrange(2):
        tRpsf, tRpsferr = fitpolyold(noise0,
                                  target_noises,
                                  Rpsf0[i],
                                  Rpsf0_err[i],
                                  Rdt_psf[:,i],
                                  Rdt_psf_err[:,i])
        Rpsf[i] = tRpsf
        Rpsf_err[i] = tRpsferr

        for j in xrange(2):

            tR, tRerr = fitpolyold(noise0,
                                target_noises,
                                R0[i,j],
                                R0_err[i,j],
                                Rdt[:,i,j],
                                Rdt_err[:,i,j])
            R[i,j] = tR
            R_err[i,j] = tRerr

    p="%s (%.4f +/- %.4f)"
    print(p % ('R11',R[0,0], R_err[0,0]))
    print(p % ('R12',R[0,1], R_err[0,1]))
    print(p % ('R21',R[1,0], R_err[1,0]))
    print(p % ('R22',R[1,1], R_err[1,1]))

    print(p % ('Rpsf1',Rpsf[0], Rpsf_err[0]))
    print(p % ('Rpsf2',Rpsf[1], Rpsf_err[1]))

    '''
    plt=biggles.FramedPlot()
    xrng=[0, 1.1*diff_noise2.max()]
    
    plt.xrange=xrng
    plt.yrange= [1.1*Rnoise[:,0,0].min(), 0.0]
    plt.aspect_ratio=1.0
    plt.xlabel=r'$\Delta n^2$'
    plt.ylabel=r'$\Delta R$'

    pts1 = biggles.Points(diff_noise2, Rnoise[:,0,0], color='blue',
                          type='filled circle')
    err1 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,0,0],
                                       Rnoise_err[:,0,0],
                                       color='blue')

    pts2 = biggles.Points(diff_noise2, Rnoise[:,1,1], color='red',
                          type='filled square')
    err2 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,1,1],
                                       Rnoise_err[:,1,1],
                                       color='red')
    pts1.label=r'$\Delta R_{1,1}$'
    pts2.label=r'$\Delta R_{2,2}$'

    xvals=numpy.linspace(0, xrng[1])
    yvals11 = res_R11['offset']  + res_R11['slope']*xvals
    yvals22 = res_R22['offset']  + res_R22['slope']*xvals
    c1=biggles.Curve(xvals,yvals11,color='blue',type='solid')
    c2=biggles.Curve(xvals,yvals22,color='red',type='dashed')

    key=biggles.PlotKey(0.9, 0.9, [pts1, pts2],
                        halign='right')
    plt.add(c1, c2, pts1, err1, pts2, err2, key)

    plotfile=files.get_plot_url(args.run, 'Rnoise-detrend')

    print("writing:",plotfile)
    eu.ostools.makedirs_fromfile(plotfile)
    plt.write_eps(plotfile)

    if args.show:
        plt.show()
    '''
    return R, R_err, Rpsf, Rpsf_err


def get_s2n_weights(s2n, args):
    #return numpy.ones(s2n.size)
    print("s2n soft:",args.s2n_soft)
    wts = 1.0/(1.0 + (args.s2n_soft/s2n)**2 )
    return wts

def get_Rnoise_line(conf, args, data, weights=None):

    noise0 = conf['simc']['noise']
    factors=array(conf['detrend_factors'])
    target_noises = noise0*factors
    ndiff = target_noises - noise0
    xvals = 2*noise0*ndiff

    if weights is not None:
        wsum=weights.sum()
        #wna1=weights[:,newaxis]
        #wna2=weights[:,newaxis,newaxis]
        #wna3=weights[:,newaxis,newaxis,newaxis]

        R = data['mcal_dt_Rnoise']
        #Rpsf = data['mcal_dt_Rnoise_psf']
        Rshape=R.shape[1:]
        #Rpsf_shape=Rpsf.shape[1:]

        Rdt = numpy.zeros(Rshape)
        #Rdt_psf = numpy.zeros(Rpsf_shape)

        for i in xrange(Rshape[0]):
            for j in xrange(Rshape[1]):
                for k in xrange(Rshape[2]):
                    Rdt[i,j,k] = (R[:,i,j,k]*weights).sum()/wsum

        #for i in xrange(Rpsf_shape[0]):
        #    for j in xrange(Rpsf_shape[1]):
        #        Rdt_psf[i,j] = (Rpsf[:,i,j]*weights).sum()/wsum


        #Rdt = (data['mcal_dt_Rnoise']*wna3).sum(axis=0)/wsum
        #Rdt_psf = (data['mcal_dt_Rnoise_psf']*wna2).sum(axis=0)/wsum

        #Rdt = eu.stat.wmom(data['mcal_dt_Rnoise'], weights)
        #Rdt_psf = eu.stat.wmom(data['mcal_dt_Rnoise_psf'], weights)

    else:
        Rdt = data['mcal_dt_Rnoise'].mean(axis=0)
        #Rdt_psf = data['mcal_dt_Rnoise_psf'].mean(axis=0)

    A = zeros( (2,2) )
    #Apsf = zeros(2)

    p='%s (%.3g +/- %.3g) + (%.3g +/ %.3g) deltan'
    for i in xrange(2):
        '''
        res = fitline(xvals, Rdt_psf[:,i])
        Apsf[i] = res['slope']

        plot_line_fit(
            args,
            'Rnoise-detrend-Rpsf%d' % (i+1),
            xvals, Rdt_psf[:,i],res,
            r'$2 n \Delta n$',
            r'$\Delta R^{PSF}_%d$' % (i+1),
        )
        '''

        for j in xrange(2):
            res = fitline(xvals, Rdt[:,i,j])
            #A[i,j] = res['slope']/2.0/noise0
            A[i,j] = res['slope']

            n='A[%d,%d]' % (i+1,j+1)
            s=res['slope']
            serr=res['slope_err']
            o=res['offset']
            oerr=res['offset_err']
            print(p % (n,o,oerr,s,serr))

            plot_line_fit(
                args,
                'Rnoise-detrend-R%d%d' % (i+1,j+1),
                xvals, Rdt[:,i,j],res,
                r'$2 n \Delta n$',
                r'$\Delta R_{%d,%d}$' % (i+1,j+1),
            )

    Rnoise = A*noise0**2
    #Rnoise_psf = Apsf*noise0**2 

    #return Rnoise, Rnoise_psf
    return Rnoise

def plot_line_fit(args, extra, x, y, res, xlabel, ylabel):
    plt=biggles.FramedPlot()

    ymin=y.min()
    ymax=y.max()
    if ymin < 0:
        yr = [1.1*ymin, 0.0]
    else:
        yr = [0, 1.1*ymax]

    xr = [0.0, 1.1*x.max()]

    plt.xrange=xr
    plt.yrange=yr
    plt.xlabel=xlabel
    plt.ylabel=ylabel
    plt.aspect_ratio=1

    xfit = numpy.linspace(0, xr[1])
    yfit = res['offset'] + res['slope']*xfit

    pts = biggles.Points(x,y,type='filled circle')
    c = biggles.Curve(xfit, yfit, color='blue')

    alab=r'$slope = %.3g \pm %.3g' % (res['slope'],res['slope_err'])
    blab=r'$offset = %.3g \pm %.3g' % (res['offset'],res['offset_err'])
    alabel=biggles.PlotLabel(0.9, 0.9, alab, halign='right')
    blabel=biggles.PlotLabel(0.9, 0.85, blab, halign='right')

    plt.add(c, pts, alabel, blabel)

    plotfile=files.get_plot_url(args.run, extra)

    print("writing:",plotfile)
    eu.ostools.makedirs_fromfile(plotfile)
    plt.write_eps(plotfile)

    if args.show:
        plt.show()



def get_Rnoise_poly(conf, args, data):
    import fitting


    noise0 = conf['noise']
    target_noises = array( conf['target_noises'] )

    n=data.size

    Rdt = data['mcal_dt_Rnoise'].mean(axis=0)
    Rdt_err = data['mcal_dt_Rnoise'].std(axis=0)/sqrt(n)
    Rdt_psf = data['mcal_dt_Rnoise_psf'].mean(axis=0)
    Rdt_psf_err = data['mcal_dt_Rnoise_psf'].std(axis=0)/sqrt(n)

    if True:
        td=Rdt[:,0,0]

        ndiff=target_noises-noise0

        '''
        xvals = 2*target_noises*ndiff
        res=fitline(xvals, td)
        print(res)

        xr=[0, 1.1*xvals.max()]
        yr=[1.1*td.min(), 0]
        plt=biggles.plot(
            xvals, td,
            xrange=xr,
            yrange=yr,
            visible=False
        )
        sxvals=numpy.linspace(0.0, xvals.max())
        biggles.plot(sxvals,
                     res['offset'] + res['slope']*sxvals,
                     color='blue',
                     type='solid',
                     plt=plt)
 
        stop
        '''


        yr=[1.1*td.min(), 0]
        plt=biggles.plot(ndiff, td,
                     xrange=[0, 1.1*ndiff.max()],
                     yrange=yr,visible=False)
        res=fitline(ndiff, td)
        print("%g + %g deltan" % (res['offset'],res['slope']))
        xvals=numpy.linspace(0.0, ndiff.max())
        biggles.plot(xvals,
                     res['offset'] + res['slope']*xvals,
                     color='blue',
                     type='solid',
                     plt=plt)

        A = res['slope']/2.0/noise0

        Rnoise = A*noise0**2
        print("Rnoise:",Rnoise)
        stop
        

    A = zeros( (2,2) )
    A_err = zeros( (2,2) )
    Apsf = zeros(2)
    Apsf_err = zeros(2)
    
    B = zeros( (2,2) )
    B_err = zeros( (2,2) )
    Bpsf = zeros(2)
    Bpsf_err = zeros(2)
 
    for i in xrange(2):
        res = fitpoly(noise0,
                      target_noises,
                      Rdt_psf[:,i],
                      Rdt_psf_err[:,i])

        pars=res['pars']
        print("Apsf:",pars)
        perr=res['perr']
        Apsf[i] = pars[0]
        Apsf_err[i] = perr[0]
        Bpsf[i] = pars[1]
        Bpsf_err[i] = perr[1]

        for j in xrange(2):
            res = fitpoly(noise0,
                           target_noises,
                           Rdt[:,i,j],
                           Rdt_err[:,i,j])
            pars=res['pars']
            perr=res['perr']
            print("    A:",pars)
            A[i,j] = pars[0]
            A_err[i,j] = perr[0]
            B[i,j] = pars[1]
            B_err[i,j] = perr[1]

    #Rnoise = noise0 *A
    #Rnoise_err = noise0 *A_err
    #Rnoise_psf = noise0 *Apsf
    #Rnoise_psf_err = noise0 *Apsf_err

    #Rnoise = noise0**2 *A
    #Rnoise_err = noise0**2 *A_err
    #Rnoise_psf = noise0**2 *Apsf
    #Rnoise_psf_err = noise0**2 *Apsf_err

    Rnoise = noise0**2 * B
    Rnoise_err = noise0**2 * B_err
    Rnoise_psf = noise0**2 * Bpsf
    Rnoise_psf_err = noise0**2 * Bpsf_err

    p="%s (%.4f +/- %.4f)"
    print(p % ('R11',Rnoise[0,0], Rnoise_err[0,0]))
    print(p % ('R12',Rnoise[0,1], Rnoise_err[0,1]))
    print(p % ('R21',Rnoise[1,0], Rnoise_err[1,0]))
    print(p % ('R22',Rnoise[1,1], Rnoise_err[1,1]))

    print(p % ('Rpsf1',Rnoise_psf[0], Rnoise_psf_err[0]))
    print(p % ('Rpsf2',Rnoise_psf[1], Rnoise_psf_err[1]))

    return Rnoise, Rnoise_psf


    '''
    plt=biggles.FramedPlot()
    xrng=[0, 1.1*diff_noise2.max()]
    
    plt.xrange=xrng
    plt.yrange= [1.1*Rnoise[:,0,0].min(), 0.0]
    plt.aspect_ratio=1.0
    plt.xlabel=r'$\Delta n^2$'
    plt.ylabel=r'$\Delta R$'

    pts1 = biggles.Points(diff_noise2, Rnoise[:,0,0], color='blue',
                          type='filled circle')
    err1 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,0,0],
                                       Rnoise_err[:,0,0],
                                       color='blue')

    pts2 = biggles.Points(diff_noise2, Rnoise[:,1,1], color='red',
                          type='filled square')
    err2 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,1,1],
                                       Rnoise_err[:,1,1],
                                       color='red')
    pts1.label=r'$\Delta R_{1,1}$'
    pts2.label=r'$\Delta R_{2,2}$'

    xvals=numpy.linspace(0, xrng[1])
    yvals11 = res_R11['offset']  + res_R11['slope']*xvals
    yvals22 = res_R22['offset']  + res_R22['slope']*xvals
    c1=biggles.Curve(xvals,yvals11,color='blue',type='solid')
    c2=biggles.Curve(xvals,yvals22,color='red',type='dashed')

    key=biggles.PlotKey(0.9, 0.9, [pts1, pts2],
                        halign='right')
    plt.add(c1, c2, pts1, err1, pts2, err2, key)

    plotfile=files.get_plot_url(args.run, 'Rnoise-detrend')

    print("writing:",plotfile)
    eu.ostools.makedirs_fromfile(plotfile)
    plt.write_eps(plotfile)

    if args.show:
        plt.show()
    '''


def get_Rnoise_numpy_poly(conf, args, data):
    import fitting
    from numpy import polyfit


    noise0 = conf['noise']
    target_noises = numpy.array( conf['target_noises'] )

    diff_noise2 = target_noises**2 - noise0**2

    n=data.size
    Rnoise = data['mcal_dt_Rnoise'].mean(axis=0)
    Rnoise_err = data['mcal_dt_Rnoise'].std(axis=0)/sqrt(n)
    Rnoise_psf = data['mcal_dt_Rnoise_psf'].mean(axis=0)
    Rnoise_psf_err = data['mcal_dt_Rnoise_psf'].std(axis=0)/sqrt(n)

    #p="R%d%d (%.4f +/- %.4f) dn^2 + (%.4f +/- %.4f)"
    p="A: %d%d %.4f dn^2 + %.4f"

    A = zeros( (2,2) )
    A_err = zeros( (2,2) )
    off = zeros( (2,2) )
    off_err = zeros( (2,2) )
    Apsf = zeros(2)
    Apsf_err = zeros(2)
    off_psf = zeros(2)
    off_psf_err = zeros(2)
 
    order=1
    for i in xrange(2):
        coeff,cov=polyfit(diff_noise2, Rnoise_psf[:,i],
                          order,cov=True)
        Apsf[i] = coeff[0]
        off_psf[i] = coeff[1]
        for j in xrange(2):
            coeff,cov=polyfit(diff_noise2, Rnoise[:,i,j],
                              order,cov=True)
            A[i,j] = coeff[0]
            off[i,j] = coeff[1]

            print(p % (i,j,A[i,j],off[i,j]))


    if args.sub_offset:
        print("subtracting offset")
        Rnoise_mean -= array( [[res_R11['offset'], res_R12['offset']],
                               [res_R21['offset'], res_R22['offset']] ] )
        Rnoise_psf_mean -= array( [res_Rpsf1['offset'], res_Rpsf2['offset'] ])


    biggles.configure('default','fontsize_min',1)

    plt=biggles.FramedPlot()
    xrng=[0, 1.1*diff_noise2.max()]
    
    plt.xrange=xrng
    plt.yrange= [1.1*Rnoise[:,0,0].min(), 0.0]
    plt.aspect_ratio=1.0
    plt.xlabel=r'$\Delta n^2$'
    plt.ylabel=r'$\Delta R$'

    pts1 = biggles.Points(diff_noise2, Rnoise[:,0,0], color='blue',
                          type='filled circle')
    err1 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,0,0],
                                       Rnoise_err[:,0,0],
                                       color='blue')

    pts2 = biggles.Points(diff_noise2, Rnoise[:,1,1], color='red',
                          type='filled square')
    err2 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,1,1],
                                       Rnoise_err[:,1,1],
                                       color='red')
    pts1.label=r'$\Delta R_{1,1}$'
    pts2.label=r'$\Delta R_{2,2}$'

    xvals=numpy.linspace(0, xrng[1])
    yvals11 = off[0,0]  + A[0,0]*xvals
    yvals22 = off[1,1]  + A[1,1]*xvals
    c1=biggles.Curve(xvals,yvals11,color='blue',type='solid')
    c2=biggles.Curve(xvals,yvals22,color='red',type='dashed')

    key=biggles.PlotKey(0.9, 0.9, [pts1, pts2],
                        halign='right')
    plt.add(c1, c2, pts1, err1, pts2, err2, key)

    plotfile=files.get_plot_url(args.run, 'Rnoise-detrend')

    print("writing:",plotfile)
    eu.ostools.makedirs_fromfile(plotfile)
    plt.write_eps(plotfile)

    if args.show:
        plt.show()

    R = noise0**2 * A
    Rpsf = noise0**2 * Apsf
    return R, Rpsf


def get_Rnoise_quad(conf, args, data):
    import fitting


    noise0 = conf['noise']
    target_noises = numpy.array( conf['target_noises'] )

    diff_noise2 = target_noises**2 - noise0**2

    n=data.size
    Rnoise = data['mcal_dt_Rnoise'].mean(axis=0)
    Rnoise_err = data['mcal_dt_Rnoise'].std(axis=0)/sqrt(n)
    Rnoise_psf = data['mcal_dt_Rnoise_psf'].mean(axis=0)
    Rnoise_psf_err = data['mcal_dt_Rnoise_psf'].std(axis=0)/sqrt(n)

    res_R11=fitline(diff_noise2, Rnoise[:,0,0])
    res_R12=fitline(diff_noise2, Rnoise[:,0,1])
    res_R21=fitline(diff_noise2, Rnoise[:,1,0])
    res_R22=fitline(diff_noise2, Rnoise[:,1,1])

    res_Rpsf1=fitline(diff_noise2, Rnoise_psf[:,0])
    res_Rpsf2=fitline(diff_noise2, Rnoise_psf[:,1])

    '''
    res_R11=fitline_zero_offset(diff_noise2, Rnoise[:,0,0])
    res_R12=fitline_zero_offset(diff_noise2, Rnoise[:,0,1])
    res_R21=fitline_zero_offset(diff_noise2, Rnoise[:,1,0])
    res_R22=fitline_zero_offset(diff_noise2, Rnoise[:,1,1])

    res_Rpsf1=fitline_zero_offset(diff_noise2, Rnoise_psf[:,0])
    res_Rpsf2=fitline_zero_offset(diff_noise2, Rnoise_psf[:,1])
    '''



    p="%s (%.4f +/- %.4f) + (%.4f +/- %.4f) delta n^2"
    print(p % ('R11',res_R11['offset'],res_R11['offset_err'],
               res_R11['slope'],res_R11['slope_err']))

    print(p % ('R12',res_R12['offset'],res_R12['offset_err'],
               res_R12['slope'],res_R12['slope_err']))

    print(p % ('R21',res_R21['offset'],res_R21['offset_err'],
               res_R21['slope'],res_R21['slope_err']))

    print(p % ('R22',res_R22['offset'],res_R22['offset_err'],
               res_R22['slope'],res_R22['slope_err']))

    print(p % ('Rpsf1',res_Rpsf1['offset'],res_Rpsf1['offset_err'],
               res_Rpsf1['slope'],res_Rpsf1['slope_err']))
    print(p % ('Rpsf2',res_Rpsf2['offset'],res_Rpsf2['offset_err'],
               res_Rpsf2['slope'],res_Rpsf2['slope_err']))

    #Rnoise_mean = array( [[res_R11['offset'], res_R12['offset']],
    #                 [res_R21['offset'], res_R22['offset']] ] )

    #Rnoise_psf_mean = array( [res_Rpsf1['offset'], res_Rpsf2['offset'] ])

    Rnoise_mean = noise0*array( [[res_R11['slope'], res_R12['slope']],
                                 [res_R21['slope'], res_R22['slope']] ] )

    Rnoise_psf_mean = noise0*array( [res_Rpsf1['slope'], res_Rpsf2['slope'] ])


    if args.sub_offset:
        print("subtracting offset")
        Rnoise_mean -= array( [[res_R11['offset'], res_R12['offset']],
                               [res_R21['offset'], res_R22['offset']] ] )
        Rnoise_psf_mean -= array( [res_Rpsf1['offset'], res_Rpsf2['offset'] ])


    biggles.configure('default','fontsize_min',1)

    plt=biggles.FramedPlot()
    xrng=[0, 1.1*diff_noise2.max()]
    
    plt.xrange=xrng
    plt.yrange= [1.1*Rnoise[:,0,0].min(), 0.0]
    plt.aspect_ratio=1.0
    plt.xlabel=r'$\Delta n^2$'
    plt.ylabel=r'$\Delta R$'

    pts1 = biggles.Points(diff_noise2, Rnoise[:,0,0], color='blue',
                          type='filled circle')
    err1 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,0,0],
                                       Rnoise_err[:,0,0],
                                       color='blue')

    pts2 = biggles.Points(diff_noise2, Rnoise[:,1,1], color='red',
                          type='filled square')
    err2 = biggles.SymmetricErrorBarsY(diff_noise2,
                                       Rnoise[:,1,1],
                                       Rnoise_err[:,1,1],
                                       color='red')
    pts1.label=r'$\Delta R_{1,1}$'
    pts2.label=r'$\Delta R_{2,2}$'

    xvals=numpy.linspace(0, xrng[1])
    yvals11 = res_R11['offset']  + res_R11['slope']*xvals
    yvals22 = res_R22['offset']  + res_R22['slope']*xvals
    c1=biggles.Curve(xvals,yvals11,color='blue',type='solid')
    c2=biggles.Curve(xvals,yvals22,color='red',type='dashed')

    key=biggles.PlotKey(0.9, 0.9, [pts1, pts2],
                        halign='right')
    plt.add(c1, c2, pts1, err1, pts2, err2, key)

    plotfile=files.get_plot_url(args.run, 'Rnoise-detrend')

    print("writing:",plotfile)
    eu.ostools.makedirs_fromfile(plotfile)
    plt.write_eps(plotfile)

    if args.show:
        plt.show()

    return Rnoise_mean, Rnoise_psf_mean

def main():
    args = parser.parse_args()

    conf = nsim.files.read_config(args.run)
    conf['simc'] = nsim.files.read_config(conf['sim'])

    data=read_data(conf, args, cache=args.cache)

    means = get_averages(conf, args, data, show_progress=False)
    fits=fit_m_c(means)
    doplot(args, means, fits)

main()
