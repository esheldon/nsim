#!/usr/bin/env python
from __future__ import print_function
import sys
import os
import numpy
from numpy import sqrt, array, diag, ones, zeros, where, newaxis

import fitsio

import ngmix
import nsim
from nsim import files

import argparse
import esutil as eu


fclass=argparse.ArgumentDefaultsHelpFormatter
parser=argparse.ArgumentParser(formatter_class=fclass)

parser.add_argument('run', help='run to use in fit')

parser.add_argument('--show',action='store_true',help='show plot')
parser.add_argument('--yrange', help="yrange of plot")
parser.add_argument('--xrange', help="xrange of plot")

parser.add_argument('--fit-only',action='store_true',
                    help='get the means from the written file')

parser.add_argument('--cache',action='store_true',
                    help=('cache the file subset locally; use the cache '
                          'if available'))



def read_data(conf, dt_index=None, cache=False):

    if cache:
        return read_cached_data(conf, dt_index=dt_index)

    chunksize=1000000

    columns=['shear_index','mcal_gpsf']
    if dt_index is not None:
        columns += [
            'mcal_dt_g',
            'mcal_dt_R',
            'mcal_dt_Rpsf',
        ]
    else:
        columns += [
            'mcal_g',
            'mcal_R',
            'mcal_Rpsf',
        ]

    print("reading columns:",columns)
    dt = [
        ('shear_index','i4'),
        ('g','f8',2),
        ('gpsf','f8',2),
        ('R','f8',(2,2)),
        ('Rpsf','f8',2)
    ]

    fname=files.get_output_url(conf['run'], 0, 0)
    with fitsio.FITS(fname) as fits:
        hdu = fits[1]
        nrows=hdu.get_nrows()

        data=numpy.zeros(nrows, dtype=dt)

        nchunks = nrows//chunksize

        if (nrows % chunksize) > 0:
            nchunks += 1

        beg=0
        for i in xrange(nchunks):

            end=beg+chunksize

            tdata = hdu[columns][beg:end]

            data['shear_index'][beg:beg+tdata.size] = tdata['shear_index']
            data['gpsf'][beg:beg+tdata.size] = tdata['mcal_gpsf']

            if dt_index is not None:
                data['g'][beg:beg+tdata.size] = tdata['mcal_dt_g'][:,dt_index,:]
                data['R'][beg:beg+tdata.size] = tdata['mcal_dt_R'][:,dt_index,:,:]
                data['Rpsf'][beg:beg+tdata.size] = tdata['mcal_dt_Rpsf'][:,dt_index,:]
            else:
                data['g'][beg:beg+tdata.size] = tdata['mcal_g'][:,:]
                data['R'][beg:beg+tdata.size] = tdata['mcal_R'][:,:,:]
                data['Rpsf'][beg:beg+tdata.size] = tdata['mcal_Rpsf'][:,:]
        
            beg += tdata.size

    return data

def get_cache_file(conf):
    tdir=os.environ['TMPDIR']
    tfile= nsim.files.get_output_url(conf['run'], 0, 0)
    tfile=os.path.basename(tfile)

    tfile=os.path.join(tdir, tfile)
    return tfile

def read_cached_data(conf, dt_index=None):

    tfile=get_cache_file(conf['run'])

    if os.path.exists(tfile):
        print("reading cache:",tfile)
        data=fitsio.read(tfile, dt_index=dt_index)

    else:
        data=read_data(conf, dt_index=dt_index)
        print("writing cache:",tfile)
        fitsio.write(tfile, data, clobber=True)

    return data


SIGMA2_MIN_CONSTANT_GROUND = 4.     # 2**2
NORMALIZATION_CONSTANT_SPACE = 1.232
NORMALIZATION_CONSTANT_GROUND = NORMALIZATION_CONSTANT_SPACE

CFID = 2.e-4
MFID = 2.e-3


# quick line fit pulled from great3-public code
def _calculateSvalues(xarr, yarr, sigma2=1.):
    """Calculates the intermediate S values required for basic linear regression.

    See, e.g., Numerical Recipes (Press et al 1992) Section 15.2.
    """
    if len(xarr) != len(yarr):
        raise ValueError("Input xarr and yarr differ in length!")
    if len(xarr) <= 1:
        raise ValueError("Input arrays must have 2 or more values elements.")

    S = len(xarr) / sigma2
    Sx = numpy.sum(xarr / sigma2)
    Sy = numpy.sum(yarr / sigma2)
    Sxx = numpy.sum(xarr * xarr / sigma2)
    Sxy = numpy.sum(xarr * yarr / sigma2)
    return (S, Sx, Sy, Sxx, Sxy)

def fitline(xarr, yarr):
    """Fit a line y = a + b * x to input x and y arrays by least squares.

    Returns the tuple (a, b, Var(a), Cov(a, b), Var(b)), after performing an internal estimate of
    measurement errors from the best-fitting model residuals.

    See Numerical Recipes (Press et al 1992; Section 15.2) for a clear description of the details
    of this simple regression.
    """
    # Get the S values (use default sigma2, best fit a and b still valid for stationary data)
    S, Sx, Sy, Sxx, Sxy = _calculateSvalues(xarr, yarr)
    # Get the best fit a and b
    Del = S * Sxx - Sx * Sx
    a = (Sxx * Sy - Sx * Sxy) / Del
    b = (S * Sxy - Sx * Sy) / Del
    # Use these to estimate the sigma^2 by residuals from the best-fitting model
    ymodel = a + b * xarr
    sigma2 = numpy.mean((yarr - ymodel)**2)
    # And use this to get model parameter error estimates
    var_a  = sigma2 * Sxx / Del
    cov_ab = - sigma2 * Sx / Del
    var_b  = sigma2 * S / Del

    a_err = numpy.sqrt(var_a)
    b_err = numpy.sqrt(var_b)
    return a, a_err, b, b_err, cov_ab


def calc_q(fits):

    m1=fits['m'][0,0]
    m2=fits['m'][0,1]
    c1=fits['c'][0,0]
    c2=fits['c'][0,1]

    sigma2_min = SIGMA2_MIN_CONSTANT_GROUND 
    norm = NORMALIZATION_CONSTANT_GROUND 

    num = 2000.0 * norm
    denom = numpy.sqrt(  (c1 / CFID)**2 
                       + (c2 / CFID)**2
                       + (m1 / MFID)**2
                       + (m2 / MFID)**2
                       + sigma2_min)

    Q = num/denom
    
    print("  Q: %g" % Q)

    return Q

def doplot(args, data, fits):
    import biggles

    Q=calc_q(fits)

    if args.yrange is not None:
        yrange=[float(r) for r in args.yrange.split(',')]
    else:
        yrange=[-0.01,0.01]

    xrng=args.xrange
    if xrng is not None:
        xrng=[float(r) for r in args.xrange.split(',')]

    tab=biggles.Table(1,2)
    tab.aspect_ratio=0.5

    diff = data['shear'] - data['shear_true']

    plts=[]
    for i in [0,1]:

        x = data['shear_true'][:,i]
        plt =biggles.plot(
            x,
            diff[:,i],
            xlabel='shear%d true' % (i+1,),
            ylabel='shear%d diff' % (i+1,),
            yrange=yrange,
            xrange=xrng,
            visible=False,
        )
        yfit=fits['m'][0,i]*x + fits['c'][0,i]

        c=biggles.Curve(x, yfit, color='red')
        z=biggles.Curve(x, x*0, color='black')
        plt.add(c,z)

        mstr='m%d: %.2g +/- %.2g' % (i+1,fits['m'][0,i],fits['merr'][0,i])
        cstr='c%d: %.2g +/- %.2g' % (i+1,fits['c'][0,i],fits['cerr'][0,i])
        mlab=biggles.PlotLabel(0.1,0.9,
                               mstr,
                               halign='left')
        clab=biggles.PlotLabel(0.1,0.85,
                               cstr,
                               halign='left')
        plt.add(mlab,clab)
        if i==0:
            Qstr='Q: %d' % (int(Q),)
            Qlab=biggles.PlotLabel(0.1,0.8,
                                   Qstr,
                                   halign='left')
            plt.add(Qlab)


        tab[0,i] = plt

    #fname=reredux.files.get_fit_file(args.run,
    #                                 extra='fit-m-c',
    #                                 ext='eps')
    #eu.ostools.makedirs_fromfile(fname)
    #print("writing:",fname)
    #tab.write_eps(fname)

    if args.show:
        tab.show(width=1000, height=1000)

def write_fits(args, fits):
    fname=reredux.files.get_fit_file(args.run, extra='fit-m-c')

    eu.ostools.makedirs_fromfile(fname)
    print("writing fit data to file:",fname)
    fitsio.write(fname, fits, clobber=True)

def get_mean_struct(n):
    dt=[('shear','f8',2),
        ('shear_true','f8',2),
        ('shear_err','f8',2)]

    means = numpy.zeros(n, dtype=dt)
    return means

def read_means(args):
    return reredux.files.read_fit_file(args.run,
                                       extra='shear-means')
def write_means(args, means):
    fname=reredux.files.get_fit_file(args.run,
                                     extra='shear-means')
    eu.ostools.makedirs_fromfile(fname)

    print("writing:",fname)
    fitsio.write(fname, means, clobber=True)


def print_shear(ind, num, shear, shear_err):
    mess="  %d: %d  %g +/- %g  %g +/- %g"
    tup=(ind, num, shear[0],shear_err[0], shear[1],shear_err[1])
    print(mess % tup)

def get_averages(conf, data, show_progress=True):

    sconf=conf['simc']
    shears = sconf['shear']['shears']

    h,rev = eu.stat.histogram(data['shear_index'], rev=True)
    nind = h.size

    g=data['g']
    gpsf=data['gpsf']
    R=data['R']
    Rpsf=data['Rpsf']

    means=get_mean_struct(nind)

    for i in xrange(nind):
        if show_progress:
            print("shear index:",i)

        w=rev[ rev[i]:rev[i+1] ]

        shear_true = shears[i]

        Rmean = R[w].mean(axis=0)
        Rinv = numpy.linalg.inv(Rmean)

        psf_corr  = (gpsf[w]*Rpsf[w]).mean(axis=0)

        gmean     = g[w].mean(axis=0)
        shear     = numpy.dot(Rinv, gmean-psf_corr)
        shear_err = g[w].std(axis=0)/numpy.sqrt(w.size)
        shear_err = numpy.dot(Rinv, shear_err)

        means['shear'][i] = shear
        means['shear_err'][i] = shear_err
        means['shear_true'][i] = shear_true

    return means

def print_m_c(sindex, m, merr, c, cerr, r=None):
    fmt = '  m{i}: %.3e +/- %.3e c{i}: %.3e +/- %.3e'.format(i=sindex)
    if r is not None:
        fmt += '  r{i}: %.3g'.format(i=sindex)
        print(fmt % (m, merr, c, cerr,r))
    else:
        print(fmt % (m, merr, c, cerr))

def fit_m_c(data, doprint=True):
    import fitting
    import mcmc
    import esutil as eu

    strue = data['shear_true']
    sdiff = data['shear'] - data['shear_true']
    #serr = data['shear_err']

    m = numpy.zeros(2)
    merr = numpy.zeros(2)
    c = numpy.zeros(2)
    cerr = numpy.zeros(2)

    fits=numpy.zeros(1, dtype=[('m','f8',2),
                               ('merr','f8',2),
                               ('c','f8',2),
                               ('cerr','f8',2),
                               ('r','f8',2)])
    for i in [0,1]:
        w,=numpy.where(strue[:,i] != 0.0)
        if w.size == 0:
            print("shear is zero, mean for all is")
            m,e=eu.stat.wmom(data['shear'][:,i],
                             1.0/data['shear_err'][:,i]**2,
                             calc_err=True)
            print("s%d: %.3e +/- %.3e" % (i+1,m,e))
        else:
            if True:
                c, c_err, m, m_err, covar = fitline(strue[:,i], sdiff[:,i])
                r = covar/numpy.sqrt(m_err**2 * c_err**2)
                fits['m'][0,i] = m
                fits['merr'][0,i] = m_err
                fits['c'][0,i] = c
                fits['cerr'][0,i] = c_err
                fits['r'][0,i] = r

                if doprint:
                    print_m_c(i+1, m,m_err,c,c_err, r=r)
            else:
                fit = fitting.fit_line(strue[:,i],
                                       sdiff[:,i],
                                       yerr=serr[:,i])
                res = fit.get_result()
                p=res['pars']
                perr=res['perr']

                if doprint:
                    print_m_c(i+1, p[0],perr[0],p[1],perr[1])

                fits['m'][0,i] = p[0]
                fits['merr'][0,i] = perr[0]
                fits['c'][0,i] = p[1]
                fits['cerr'][0,i] = perr[1]

    return fits

def correct_means(conf, all_means, args):
    import fitting

    noise0 = conf['noise']
    target_noises = numpy.array( conf['target_noises'] )

    noises2 = numpy.zeros(1+target_noises.size)
    noises2[0] = conf['noise']**2
    noises2[1:] = target_noises**2


    ratio = numpy.ones( (noises2.size, 2) )
    ratio_err = numpy.ones( (noises2.size, 2) )
    for i in xrange(0,noises2.size):
        #r = all_means[i]['shear']/all_means[0]['shear']
        #rmean = r.mean(axis=0)
        #rerr = r.std(axis=0)/numpy.sqrt( r.shape[0] )
        #print("  ratio1 %d: %g +/- %g" % (i,ratio[i,0],ratio_err[i,0]))
        #print("  ratio2 %d: %g +/- %g" % (i,ratio[i,1],ratio_err[i,1]))

        #ratio[i,:] = rmean
        #ratio_err[i,:] = rerr

        offset1,oerr,slope1,s1err,cov=fitline(all_means[0]['shear'][:,0],all_means[i]['shear'][:,0])
        offset2,oerr,slope2,s2err,cov=fitline(all_means[0]['shear'][:,1],all_means[i]['shear'][:,1])

        print("-"*70)
        print("  s1 %d: %g + %g * s1(0)" % (i,offset1,slope1))
        print("  s2 %d: %g + %g * s2(0)" % (i,offset2,slope2))

        ratio[i,:] = slope1,slope2
        ratio_err[i,:] = s1err,s2err

    print("-"*70)
    ratio_err[0,:] = ratio_err[1,:]

    '''
    fit1 = fitting.fit_line(noises2, ratio[:,0], yerr=ratio_err[:,0])
    res = fit1.get_result()
    slope1,offset1=res['pars']
    slope1err,offset1err=res['perr']

    fit2 = fitting.fit_line(noises2, ratio[:,1], yerr=ratio_err[:,1])
    res = fit2.get_result()
    slope2,offset2=res['pars']
    slope2err,offset2err=res['perr']
    '''

    #offset1,oerr,slope1,serr,cov=fitline(noises2, ratio[:,0]) 
    #offset2,oerr,slope2,serr,cov=fitline(noises2, ratio[:,1]) 
    offset1,oerr,slope1,serr,cov=fitline(noises2[1:], ratio[1:,0]) 
    offset2,oerr,slope2,serr,cov=fitline(noises2[1:], ratio[1:,1]) 

    print("fit g1")
    print("%g + %g * g1" % (offset1,slope1))
    print("fit g2")
    print("%g + %g * g2" % (offset2,slope2))

    new_means=all_means[0].copy()
    new_means['shear'][:,0] *= offset1
    new_means['shear'][:,1] *= offset2
    new_means['shear_err'][:,0] *= offset1
    new_means['shear_err'][:,1] *= offset2

    if args.show:
        import biggles
        xrng=[0, 1.1*noises2.max()]
        plt=biggles.plot(noises2, ratio[:,0], yerr=ratio_err[:,0],
                         color='blue',visible=False,
                         xlabel='noise**2',
                         ylabel='<shear/shear0>',
                         xrange=xrng)
        plt=biggles.plot(noises2, ratio[:,1], yerr=ratio_err[:,1],
                         color='red',visible=False,
                         plt=plt)

        xvals=numpy.linspace(0, xrng[1])
        yvals1 = offset1 + slope1*xvals
        yvals2 = offset2 + slope2*xvals
        plt.add(biggles.Curve(xvals,yvals1,color='blue',type='solid'))
        plt.add(biggles.Curve(xvals,yvals2,color='red',type='solid'))

        plt.show()

    return new_means


def main():
    args = parser.parse_args()

    conf = nsim.files.read_config(args.run)
    conf['simc'] = nsim.files.read_config(conf['sim'])

    n_target_noise = len(conf['target_noises'])

    data=read_data(conf, cache=args.cache)

    all_means=[]
    means = get_averages(conf, data, show_progress=False)
    fits=fit_m_c(means)
    all_means.append(means)

    target_means = []
    for i in xrange(n_target_noise):
        data=read_data(conf, cache=args.cache, dt_index=i)
        means = get_averages(conf, data, show_progress=False)
        fits=fit_m_c(means)

        all_means.append(means)

    means = correct_means(conf, all_means, args)

    fits=fit_m_c(means)
    doplot(args, means, fits)

main()
